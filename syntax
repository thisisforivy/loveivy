1. Correlation query: find top 10 correlated category_id for a given beacon_id.

select dmp.impression.beacon_id, top10(dmp.data.category_id)
from dmp
where co-reach(dmp.impression.beacon_id,dmp.data.cateory_id) >1000000 AND
reach(dmp.data.category_id)>5000000


//co-rearch
select co-reach(dmp.impression.beacon_id, dmp.data.category_id) co-r
from dmp
where co-reach(dmp.impression.beacon_id,dmp.data.cateory_id) >1000000 AND
reach(dmp.data.category_id)>5000000
order by co-r 
limited by 10


The query plan would be

a. scan dmp.data table to find the candidate satify inter-entity-level filter 
reach(dmp.data.category_id)>5000000

b. catesian product of a's result with dmp.impression.beacon_id intra-entity level
and add a Seed (signature) for each row, pipeline to c.

c. group by signature, and apply inter-entity-level filter co-reach(dmp.impression.beacon_id,dmp.data.cateory_id) >1000000 

d. apply top10 aggregate function. 

2. Old CQL  for Skew

Q1. SegmentUU: select sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment1,
       sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment2...
from dmp
dates [2012_10_01,2012_10_10]

Q2. AttributeUU: 
select sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment1,
       sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment2...
from dmp
dates [2012_10_01,2012_10_10]

Q3. (Adv, Attribute)UU:
select advertiser_id,sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment1,
       sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment2...
from dmp
dates [2012_10_01,2012_10_10]
where advertiser_id in (1,2,3)

Q4. (Adv, Segment)UU:
select advertiser_id,sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment1,
       sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment2...
from dmp
dates [2012_10_01,2012_10_10]
where advertiser_id in (1,2,3)


Q5 new syntax

select co-reach (dmp.impressions.advertiser_id, exists (select count(*) from dmp.data where dmp.data.turn_category_id in (123, 456))),
       reach (exists (select count(*) from dmp.data where dmp.data.turn_category_id in (123, 456))) as segment1_UU,
       reach (exists (select count(*) from dmp.data where dmp.data.turn_category_id in (211,121) or dmp.data.turn_category_id in (345,678) )) as attribute1_UU,
from dmp
where dmp.impression.advertiser_id in (1,2,3)

New syntax

select (select count_entity(*) from dmp.data where dmp.data.turn_category_id in (xxx1,xxx2) )) S1
       (select dmp.adv_id, count_entity(*) 
        from dmp.impression, dmp.data 
        where dmp.data.turn_category_id in (xxx3, xxx4)) AdvS1,
       (select dmp.adv_id, count_entity(*) 
        from dmp.impression, dmp.data 
        where dmp.data.turn_category_id in (xxx3, xxx4, xxx5, xxx6, xxx7)) AdvA1
from flatten

select (select count_entity(*) from dmp.data where dmp.data.turn_category_id in (xxx1,xxx2) )) S1
       (select dmp.adv_id, count_entity(*) 
        from dmp.impression, dmp.data 
        where dmp.data.turn_category_id in (xxx3, xxx4)) AdvS1,
       (select dmp.adv_id, count_entity(*) 
        from dmp.impression, dmp.data 
        where dmp.data.turn_category_id in (xxx3, xxx4, xxx5, xxx6, xxx7)) AdvA1
from as_is




??? yet to be defined.

select adv_id, count_entity(*)
from dmp.impression, dmp.data
where dmp.data.turn_category_id in (xxx1,xxx2)

select count_entity(*) 
from dmp.data
where dmp.data.turn_category_id in (xxx1, xxx2) 






 
3. Old CQL for reach 

select provider_user_id, count(distinct user_id)
from dmp.provider_user_ids
dates [2013_01_01, 2014_05_01]
where provider_user_id in ('007002006890000145313', '013003011370000902322')
and provider_id =3310169



The CQL introduces unnest and fetch operators.

select adv_id, count(case when list_has (dmp.data.category_id, 123) 1 else 0)
from dmp.impressions
dates[]
where adv_id = 123

The query plan is 

0. fetch dmp.data.category_id

1. while(unnest dmp.impressions is true)
    evaluate(list_function) to a scala value.

2. stream up to group by. 

Note1: we only support scala subquery. That is, all list function will evaluate to 1 scala.
The correlated subquery is ok too. That is, the list function will take a parameter from the outer 
query, and evaluate the list function.

Note2:  we support two level deep unnest on the outer query's table. However, it is hard coded for the second level.

Note3: One query may have 1 scanner (including unnest) and multiple list fetch operators. The fetch is always independent. We first maintain a list of nested table we want to fetch. And fetch them, then share the results.

Note4: agg(distinct col) means we de-dup within user.

The shortcomming of above, is that we do not support cartesian product(join) between two nested table. So, we cannot 
do frequent patten mining  between two tables. 
See UniversalProfileQueryMapper.java
See NestedColumnOperator.java. It actually supports ListLong, ListString, ListFloat type in database generic type (see Value.java).



A new query engine support within entity nested-tables relational algebra.


-- catesian product mining, entity level aggregate
select dmp.impression.beacon_id, dmp.data.category_id, count_entity(*) as A
from dmp.impression, dmp.data
where count_entity(dmp.data.category_id)>200000
group by  dmp.impression.beacon_id, dmp.data.category_id
having A >10000
order by dmp.impression.beacon_id, count(distinct user_id), dmp.data.category_id
limited dmp.data.category_id by 10 each group


-- join mining, entity level aggregate
select dmp.impression.beacon_id, dmp.data.category_id, count_entity(*) as A
from dmp.impression, dmp.data
where count_entity(dmp.data.category_id)>200000 AND dmp.impression.contract_id = dmp.data.contract_id
group by  dmp.impression.beacon_id, dmp.data.category_id
having A >10000
order by dmp.impression.beacon_id, count(distinct user_id), dmp.data.category_id
limited by 10 each group

-- record level aggregate, still witin user.
select dmp.impression.beacon_id, dmp.data.category_id, count(*) as A
from dmp.impression, dmp.data
where count_entity(dmp.data.category_id)>200000 AND dmp.impression.contract_id = dmp.data.contract_id
group by  dmp.impression.beacon_id, dmp.data.category_id
having A >10000
order by dmp.impression.beacon_id, count(distinct user_id), dmp.data.category_id
limited by 10 each group

-- old correlated query
select adv_id, count(distinct case when list_has(dmp.data.adv_id, adv_id) then 1 else 0)
from dmp.impressions
date[]

-- new syntax
select dmp.impression.adv_id, dmp.data.adv_id, count_entity(*) as A
from dmp.impression, dmp.data
where   dmp.impression.adv_id = dmp.data.adv_id

MTA

select (select dmp.clicks.impression_id, 
               dmp.impressions.impression_id, 
               count_entity(*),
                POPULATION - count_entity(*)
        from dmp.clicks as c, dmp.impression as i
        where c.impression_id in (123,456,789) and
              c.ts > i.ts and i.impression_id in ('abc', 'efg', 'hij')
       ) as 1st_order,

       (select dmp.clicks.impression_id, 
               i1.impression_id, 
               i2.impression_id,  
               count_entity(*), 
               POPULATION-count_entity(*)
        from   dmp.clicks as c, 
               dmp.impression as i1, 
               dmp.impression as i2
        where  c.impression_id in (123,456,789) and
               c.ts > i1.ts and c.ts >i2.ts and 
               i1.impression_id in ('abc', 'efg', 'hij') and
               i1.impression_id <> i2.impression_id and 
               i2.impression_id in ('abc', 'efg','hij')
        )as 2nd_order,
from  CONCAT

1, t1, 12,13         1,t1,t2, 123, 121
1, t2, 1121,121      1,t1,t3, 1231,231
1, t3, 23,23         1,t2,t3, 23234,2342
2, t1, 12,13         2,t1,t2, 232,232
2, t2, 1121,121      2,t1,t3, 234,232
2, t3, 23,23         3,t2,t3,2342,2342





























