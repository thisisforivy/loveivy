1. Correlation query: find top 10 correlated category_id for a given beacon_id.

select dmp.impression.beacon_id, top10(dmp.data.category_id)
from dmp
where co-reach(dmp.impression.beacon_id,dmp.data.cateory_id) >1000000 AND
reach(dmp.data.category_id)>5000000


//co-rearch
select co-reach(dmp.impression.beacon_id, dmp.data.category_id) co-r
from dmp
where co-reach(dmp.impression.beacon_id,dmp.data.cateory_id) >1000000 AND
reach(dmp.data.category_id)>5000000
order by co-r 
limited by 10


The query plan would be

a. scan dmp.data table to find the candidate satify inter-entity-level filter 
reach(dmp.data.category_id)>5000000

b. catesian product of a's result with dmp.impression.beacon_id intra-entity level
and add a Seed (signature) for each row, pipeline to c.

c. group by signature, and apply inter-entity-level filter co-reach(dmp.impression.beacon_id,dmp.data.cateory_id) >1000000 

d. apply top10 aggregate function. 

2. Old CQL  for Skew

Q1. SegmentUU: select sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment1,
       sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment2...
from dmp
dates [2012_10_01,2012_10_10]

Q2. AttributeUU: 
select sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment1,
       sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment2...
from dmp
dates [2012_10_01,2012_10_10]

Q3. (Adv, Attribute)UU:
select advertiser_id,sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment1,
       sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment2...
from dmp
dates [2012_10_01,2012_10_10]
where advertiser_id in (1,2,3)

Q4. (Adv, Segment)UU:
select advertiser_id,sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment1,
       sum(distinct case when list_has(dmp.data.turn_category_id,12296581, 12296609) then 1 else 0 end) segment2...
from dmp
dates [2012_10_01,2012_10_10]
where advertiser_id in (1,2,3)


Q5 new syntax

select co-reach (dmp.impressions.advertiser_id, exists (select count(*) from dmp.data where dmp.data.turn_category_id in (123, 456))),
       reach (exists (select count(*) from dmp.data where dmp.data.turn_category_id in (123, 456))) as segment1_UU,
       reach (exists (select count(*) from dmp.data where dmp.data.turn_category_id in (211,121) or dmp.data.turn_category_id in (345,678) )) as attribute1_UU,
from dmp
where dmp.impression.advertiser_id in (1,2,3)

New syntax

select (select count_entity(*) from dmp.data where dmp.data.turn_category_id in (xxx1,xxx2) )) S1
       (select dmp.adv_id, count_entity(*) 
        from dmp.impression, dmp.data 
        where dmp.data.turn_category_id in (xxx3, xxx4)) AdvS1,
       (select dmp.adv_id, count_entity(*) 
        from dmp.impression, dmp.data 
        where dmp.data.turn_category_id in (xxx3, xxx4, xxx5, xxx6, xxx7)) AdvA1
from flatten

select (select count_entity(*) from dmp.data where dmp.data.turn_category_id in (xxx1,xxx2) )) S1
       (select dmp.adv_id, count_entity(*) 
        from dmp.impression, dmp.data 
        where dmp.data.turn_category_id in (xxx3, xxx4)) AdvS1,
       (select dmp.adv_id, count_entity(*) 
        from dmp.impression, dmp.data 
        where dmp.data.turn_category_id in (xxx3, xxx4, xxx5, xxx6, xxx7)) AdvA1
from as_is




??? yet to be defined.

select adv_id, count_entity(*)
from dmp.impression, dmp.data
where dmp.data.turn_category_id in (xxx1,xxx2)

select count_entity(*) 
from dmp.data
where dmp.data.turn_category_id in (xxx1, xxx2) 






 
3. Old CQL for reach 

select provider_user_id, count(distinct user_id)
from dmp.provider_user_ids
dates [2013_01_01, 2014_05_01]
where provider_user_id in ('007002006890000145313', '013003011370000902322')
and provider_id =3310169



The CQL introduces unnest and fetch operators.

select adv_id, count(case when list_has (dmp.data.category_id, 123) 1 else 0)
from dmp.impressions
dates[]
where adv_id = 123

The query plan is 

0. fetch dmp.data.category_id

1. while(unnest dmp.impressions is true)
    evaluate(list_function) to a scala value.

2. stream up to group by. 

Note1: we only support scala subquery. That is, all list function will evaluate to 1 scala.
The correlated subquery is ok too. That is, the list function will take a parameter from the outer 
query, and evaluate the list function.

Note2:  we support two level deep unnest on the outer query's table. However, it is hard coded for the second level.

Note3: One query may have 1 scanner (including unnest) and multiple list fetch operators. The fetch is always independent. We first maintain a list of nested table we want to fetch. And fetch them, then share the results.

Note4: agg(distinct col) means we de-dup within user.

The shortcomming of above, is that we do not support cartesian product(join) between two nested table. So, we cannot 
do frequent patten mining  between two tables. 
See UniversalProfileQueryMapper.java
See NestedColumnOperator.java. It actually supports ListLong, ListString, ListFloat type in database generic type (see Value.java).



A new query engine support within entity nested-tables relational algebra.


-- catesian product mining, entity level aggregate
select dmp.impression.beacon_id, dmp.data.category_id, count_entity(*) as A
from dmp.impression, dmp.data
where count_entity(dmp.data.category_id)>200000
group by  dmp.impression.beacon_id, dmp.data.category_id
having A >10000
order by dmp.impression.beacon_id, count(distinct user_id), dmp.data.category_id
limited dmp.data.category_id by 10 each group


-- join mining, entity level aggregate
select dmp.impression.beacon_id, dmp.data.category_id, count_entity(*) as A
from dmp.impression, dmp.data
where count_entity(dmp.data.category_id)>200000 AND dmp.impression.contract_id = dmp.data.contract_id
group by  dmp.impression.beacon_id, dmp.data.category_id
having A >10000
order by dmp.impression.beacon_id, count(distinct user_id), dmp.data.category_id
limited by 10 each group

-- record level aggregate, still witin user.
select dmp.impression.beacon_id, dmp.data.category_id, count(*) as A
from dmp.impression, dmp.data
where count_entity(dmp.data.category_id)>200000 AND dmp.impression.contract_id = dmp.data.contract_id
group by  dmp.impression.beacon_id, dmp.data.category_id
having A >10000
order by dmp.impression.beacon_id, count(distinct user_id), dmp.data.category_id
limited by 10 each group

-- old correlated query
select adv_id, count(distinct case when list_has(dmp.data.adv_id, adv_id) then 1 else 0)
from dmp.impressions
date[]

-- new syntax
select dmp.impression.adv_id, dmp.data.adv_id, count_entity(*) as A
from dmp.impression, dmp.data
where   dmp.impression.adv_id = dmp.data.adv_id

MTA

select (select dmp.clicks.impression_id, 
               dmp.impressions.impression_id, 
               count_entity(*),
                POPULATION - count_entity(*)
        from dmp.clicks as c, dmp.impression as i
        where c.impression_id in (123,456,789) and
              c.ts > i.ts and i.impression_id in ('abc', 'efg', 'hij')
       ) as 1st_order,

       (select dmp.clicks.impression_id, 
               i1.impression_id, 
               i2.impression_id,  
               count_entity(*), 
               POPULATION-count_entity(*)
        from   dmp.clicks as c, 
               dmp.impression as i1, 
               dmp.impression as i2
        where  c.impression_id in (123,456,789) and
               c.ts > i1.ts and c.ts >i2.ts and 
               i1.impression_id in ('abc', 'efg', 'hij') and
               i1.impression_id <> i2.impression_id and 
               i2.impression_id in ('abc', 'efg','hij')
        ) as 2nd_order,
from  CONCAT

1, t1, 12,13         1,t1,t2, 123, 121
1, t2, 1121,121      1,t1,t3, 1231,231
1, t3, 23,23         1,t2,t3, 23234,2342
2, t1, 12,13         2,t1,t2, 232,232
2, t2, 1121,121      2,t1,t3, 234,232
2, t3, 23,23         3,t2,t3,2342,2342

New syntax

Here is a refined query syntax. Much more generic and intuitive. Aggregate function is suffixed with _within_entity, or _entity to indicate the level. Without suffix, it is record level.

select  weight_bucket(avg_within_entity(weight)) as A1, 
        blood_bucket(avg_within_entity(blood_pressure)) as A2,
        count_entity(*) as co_occurence
from mup.weight_time_series, mup.blood_pressure_time_series
where  mup.weight_time_series.ts <=180 and 
       mup.weight_time_series.ts >90 and 
      mup.blood_pressure_time_series.ts<= 180 and
      mup.blood_pressure_times_series.ts >90 and
      count_entity(A2)>1500
group by A1, co_occurence, A2
having co_occurence >1000
order by A1, co_occurence, A2
limited A2 by 10 per A1

The following one is good. The outer from clause determine what to scan, the subquery is ALWAYS 
within entity, so we can evaluate the sub query on entity fed from outer query.

select   (select weight_bucket(avg_within_entity(weight) 
          from mup.weight_time_series 
          where mup.weight_time_series.ts <=180 and 
                mup.weight_time_series.ts >90) A1,
         (select blood_bucket(avg_within_entity(blood_pressure)
          from mup.blood_pressure_time_series
          where mup.blood_pressure_time_series.ts<= 180 and
                mup.blood_pressure_times_series.ts >90) A2,
        count_entity(*) as co_occurence
from mup
group by A1, co_occurence, A2
having co_occurence >1000
order by A1, co_occurence, A2
limited A2 by 10 per A1

Use case
============
Verify  frequency cap is enforced for a given advertiser

select adv_id, list_count(dmp.impression.adv_id, adv_id), count(distinct user_id) uu
from dmp.impressions
dates last_week
where adv_id =123


This answer the question, what is the frequency map of advtiser 123. the result looks like:
123, 0, 1000
123, 1, 4000
123, 2, 2000

This clearly show we cap at 2 per user for last week.


Using new syntax, we have

select (select adv_id from dmp.impression where adv_id =123) A, (select count(*) from dmp.impressions where dmp.impressions.ts within last 7 days) B, count_entity(*)
from dmp
group by A, B






Summary
==========
Key question to address.

Q1. Why will relational model not work in big data? Isn't relational model supporting partition join, which is equalivlant to Entity partition concept?

A: there is a significant difference between these two. Entity model (2 or 3 level nested relation model) will partition user data, the join is within user. And the key 
is the co-location of the entire entity object data. Relation model cannot do this. To have two relational table colocated, we must pre-partition the data. The logical to
stich corresponding entity's row is complex. 


Key query syntax we support

1. Directly query nested table and record or entity level.

select dmp.impression.beacon_id, dmp.data.category_id, count_entity(*) as A, count(*) as B
from dmp.impression, dmp.data
where count_entity(dmp.data.category_id)>200000 AND dmp.impression.contract_id = dmp.data.contract_id
group by  dmp.impression.beacon_id, dmp.data.category_id
having A >10000
order by dmp.impression.beacon_id, count(distinct user_id), dmp.data.category_id
limited by 10 each group

2. Using scalar subquery to compute group by attributes, and group by on them.

select   (select weight_bucket(avg_within_entity(weight) 
          from mup.weight_time_series 
          where mup.weight_time_series.ts <=180 and 
                mup.weight_time_series.ts >90) A1,
         (select blood_bucket(avg_within_entity(blood_pressure)
          from mup.blood_pressure_time_series
          where mup.blood_pressure_time_series.ts<= 180 and
                mup.blood_pressure_times_series.ts >90) A2,
        count_entity(*) as co_occurence
from mup
group by A1, co_occurence, A2
having co_occurence >1000
order by A1, co_occurence, A2
limited A2 by 10 per A1

Frequency cap analysis example. 

select (select adv_id from dmp.impression where adv_id =123) A, (select count(*) from dmp.impressions where dmp.impressions.ts within last 7 days) B, count_entity(*)
from dmp
group by A, B

3. Using independent subqueries sharing one scan of entity profile to query nested table and present nested results. (MQO). Note here CONCAT indicate we do not have any correlation on the sub queries in select list. So, they do not indicates they are group by attribute or aggregate attributes.

select (select dmp.clicks.impression_id, 
               dmp.impressions.impression_id, 
               count_entity(*),
                POPULATION - count_entity(*)
        from dmp.clicks as c, dmp.impression as i
        where c.impression_id in (123,456,789) and
              c.ts > i.ts and i.impression_id in ('abc', 'efg', 'hij')
       ) as 1st_order,

       (select dmp.clicks.impression_id, 
               i1.impression_id, 
               i2.impression_id,  
               count_entity(*), 
               POPULATION-count_entity(*)
        from   dmp.clicks as c, 
               dmp.impression as i1, 
               dmp.impression as i2
        where  c.impression_id in (123,456,789) and
               c.ts > i1.ts and c.ts >i2.ts and 
               i1.impression_id in ('abc', 'efg', 'hij') and
               i1.impression_id <> i2.impression_id and 
               i2.impression_id in ('abc', 'efg','hij')
        ) as 2nd_order,
from  CONCAT

1, t1, 12,13 1,t1,t2, 123, 121
1, t2, 1121,121 1,t1,t3, 1231,231
1, t3, 23,23 1,t2,t3, 23234,2342
2, t1, 12,13 2,t1,t2, 232,232
2, t2, 1121,121 2,t1,t3, 234,232
2, t3, 23,23 3,t2,t3,2342,2342


select (select dmp.impression.adv_id, count_entity(*), count(*)
        from dmp.impression
        where dmp.impression.adv_id =123) A1,
       (select dmp.impression.adv_id, count_entity(*), count(*)
        from dmp.impression
        where dmp.impression.adv_id =456) A2,
       (select i1.adv_id, i2.adv_id, count_entity(*)
        from dmp.impression as i1, dmp.impression as i2
        where i1.adv_id =123 and i2.adv_id = 456
        group by i1.adv_id, i2.adv_id ) A3
from CONCAT


